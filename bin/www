var app = require('../app');
var debug = require('debug')('CouchTube:server');
var http = require('http');
var port = normalizePort(process.env.PORT || '3003');
app.set('port', port);
var io = app.io;
var server = http.createServer(app);
io.attach(server);
var connection = require('./connectDB');

/** 
 * Listen on provided port, on all network interfaces.
 */
server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Listen for socket events from the client and send them out
 */
io.on('connection', function(socket) {
  
  /*
   * INPUT DOC: room name and video id
   * DATABASE ACTIVITY: Add the video id to the room
   * EMITS:
   *    TO: All sockets in the room, including the sender
   *    DOC: video id
   * TODO: Check to mke sure a leader has made the request -- currently goes on every requst due to true
   */
  socket.on('RELOAD FROM CLIENT', function(data, err) {
    connection(function(db) {
      var room_collection = db.collection('room_collection');
      room_collection.findOne({room_name: data.roomName}, function(err, doc) {
        console.log(doc)
        console.log(doc.room_name)
        if (doc.room_leader == socket.id) {
          room_collection.update(
            { 'room_name': data.roomName },
            { 
              $set: {
                room_video: data.videoId,
                room_playback_time: 0,
                room_playback_state: 2
              }
            }
          );
          io.sockets.in(socket.rooms[0]).emit('RELOAD FROM SERVER', {room_video: data.videoId});
        }
      });
    });
  });

  /*
   * INPUT DOC: room name
   * DATABASE ACTIVITY: adds the room to the database if new and updates if not
   * EMITS:
   *    TO: The sender
   *    DOC: the entire room JSON + status
   * TODO: If a socket is a leader, update the leader
           If a socket is a slave, get them to the right point in the video
   *       Add other relative values and their proper behavior
   */
  socket.on('JOIN FROM CLIENT', function(doc) {
    //Case inesensitivity for the roomname
    var roomName = doc.roomName.toUpperCase();
    //removing user from io room and db room
    socket.leaveAll();
    socket.join(roomName);
    connection(function(db) {
      var room_collection = db.collection('room_collection');
      room_collection.update(
        { },
        { 
          $pull: { 
            room_users: { user_socket: socket.id } 
          } 
        }
      );
      room_collection.findOne({room_name: roomName}, function(err, doc){
        var userRole;
        /*
         * IF THE ROOM DOES NOT EXIST, CREATE IT IN THE DATABASE
         * 
         * Insert full entry room collection:
         * - name of the room
         * - new user entry: name, role, socketid
         */
        if (!doc) {
          userRole = 'leader';
          doc = {
              'room_name': roomName,
              'room_leader': socket.id,
              'room_users': [
                {
                  'user_name': '',
                  'user_role': userRole,
                  'user_socket': socket.id
                }
              ],
              'room_video': '',
              'room_playback_time': '',
              'room_playback_state': ''
          };
          room_collection.insert(doc);
        } 
        /*
         * IF THE ROOM DOES EXIST, UPDATE THE USER ENTRIES IN THE DATABASE
         *
         * Insert user entry into proper room collection
         * - new user entry: name, role, socketid
         */
        else {
          userRole = 'slave';
          var user = {
            'user_name': '',
            'user_role': userRole,
            'user_socket': socket.id
          };
          doc.room_users.push(user);
          room_collection.update(
            { 'room_name': roomName },
            { $push: { room_users: user } }
          );
        }
        doc.join_as = userRole;
        doc.room_leader = '';
        socket.emit('JOIN FROM SERVER', doc);
      });
    });
  });

  /*
   * INPUT DOC: number of player state (outdated)
   * DATABASE ACTIVITY: change the state of the room
   * EMITS:
   *    TO: all sockets but sender
   *    DOC: which state, and potentially the time
   * TODO: everything
   */
  socket.on('PLAYER STATE CHANGE FROM CLIENT', function(data, err) {
    connection(function(db) {
      var room_collection = db.collection('room_collection');
      room_collection.findOne({room_name: data.roomName}, function(err, doc) {
        if (doc.room_leader == socket.id) {
          socket.broadcast.to(socket.rooms[0]).emit('PLAYER STATE CHANGE FROM SERVER', {player_state: data.playerState, current_time: data.currentTime});
        }
      });
    });
  });

})

/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}